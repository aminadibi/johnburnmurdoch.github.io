<!doctype html>
<html class="no-js" lang="">
	<head>
		<!-- Global site tag (gtag.js) - Google Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-117177919-1"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'UA-117177919-1');
		</script>
		<meta charset="utf-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<title>The top scorers in Champions League history</title>
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<link rel="manifest" href="site.webmanifest">
		<link rel="apple-touch-icon" href="icon.png">
		<!-- Place favicon.ico in the root directory -->

		<script type='text/javascript' src='https://unpkg.com/d3@4'></script>
		<script type='text/javascript' src='https://unpkg.com/d3-selection-multi'></script>
		<script type='text/javascript' src='https://unpkg.com/d3-scale-chromatic'></script>
		<script src="https://npmcdn.com/svg-path-properties/build/path-properties.js"></script>
		<script src="reDraw.js"></script>

		<link href="https://fonts.googleapis.com/earlyaccess/mplus1p.css" rel="stylesheet" />
		<style>
			body{
				/*text-align: center;*/
			}
			body, text{
				font-family: 'Mplus 1p', Arial, sans-serif;
				font-size: 14px;
			}
			text{
				fill: #212121;
			}
			#main{
				margin: 0 auto;
				width: 100%;
				max-width: 900px;
			}
			#graphic{
				margin: 0;
				position: relative;
			}
			svg{
				position: absolute;
				pointer-events: none;
			}
			canvas{
				position: absolute;
			}
			#canvasHover{
				display: none;
			}
			#canvasOverlay{
				pointer-events: none;
				position: relative;
			}
			.voronoi path{
				fill: none;
  			pointer-events: all;
  			/*stroke: blue;*/
			}
			.player{
				pointer-events: none;
			}
			#tooltip{
				pointer-events: none;
				position: absolute;
				display: none;
			}
			#tooltip .inner{
				position: absolute;
				right: 5px;
				bottom: 5px;
				background-color: white;
				padding: 10px;
				background-color: white;
				border: 1px solid hsla(0, 0%, 0%, 0.5);
			}

			.axisToggle select{
				font-family: 'Mplus 1p', Arial, sans-serif;
				font-size: 14px;
				border: none;
				padding: 2px 5px;
				border-radius: 3px;
				background-color: #FF2B4F;
				background-color: #80c6ff;
				color: white;
				cursor: pointer;
			}

			.axisToggle select:hover{
				background-color: #33a3ff;
			}

			a{
				color: #0083EB;
			}

			@media only screen and (max-width: 500px) {
		    .tick:nth-child(odd) :not(.title) {
	        	display: none;
		    }
			}
		</style>
	</head>
<body>
<!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
<![endif]-->
<div id=main>
	<h1>The top scorers in Champions League history</h1>
	<div id=graphic>
		<div class="axisToggle y">
			Goal totals <select>
				<option value=include>include</option>
				<option value=exclude>exclude</option>
			</select> penalties
		</div>
		<canvas id=canvas></canvas>
		<canvas id=canvasHover></canvas>
		<svg></svg>
		<canvas id=canvasOverlay></canvas>		
		<div class="axisToggle x">
			Plotting goals against <select>
				<option value=date>date</option>
				<option value=minutes>minutes played</option>
				<option value=age>age</option>
			</select>
		</div>
		<div id=tooltip>
			<div class=inner></div>
		</div>
	</div>
	<div id=footer>
		<br>
		<h5>Includes statistics from the precursor to the Champions League: the European Cup</h5>
		<h4>Analysis and graphic by <a href="https://www.twitter.com/jburnmurdoch" target=_blank>@jburnmurdoch</a><br>Source: <a href="http://www.worldfootball.net" target=_blank>worldfootball.net</a></h4>
	</div>
</div>

<script type='text/javascript'>
	let container = d3.select("#main");
	let tooltip = d3.select("#tooltip");
	let offsetY = document.getElementsByTagName("svg")[0].getBoundingClientRect().top * 1.4;
	let width = container.node().clientWidth,
		height = d3.min([700, window.innerHeight-offsetY]),
		margin = {top: 30, right: 35, bottom: 30, left: 40},
		PR = window.devicePixelRatio || 1,
		scaledWidth = width*PR,
		scaledHeight = height*PR;

	function titler(axis, title){
		if(axis == "x"){
			d3.selectAll(".axis.y text.title").remove();
			d3.select(".axis.x .tick:last-of-type text")
		    .clone()
		    .attrs({
		    	class: "title",
		    	y: -5,
		    	dy: null,
		    	"font-weight": "bold"
		    })
		    .html(title);
		}else{
			d3.selectAll(".axis.y text.title").remove();
			d3.select(".axis.y .tick:last-of-type text")
		    .clone()
		    .attrs({
		    	class: "title",
		    	x: 5,
		    	"text-anchor": "start",
		    	"font-weight": "bold"
		    })
		    .text(title);
		}
	}

	let svg = container.select("svg")
		.attrs({
			width: width,
			height: height
		})
		.styles({
			width: `${width}px`,
			height:  `${height}px`
		});

	let canvas = container.select("#canvas")
		.attrs({
			width: scaledWidth,
			height: scaledHeight
		})
		.styles({
			width: `${width}px`,
			height:  `${height}px`
		});

	let context = canvas.node().getContext("2d");
	context.scale(PR, PR);
	context.font = "16px Avenir";
	context.textAlign = "center";

	let canvasHover = container.select("#canvasHover")
		.attrs({
			width: scaledWidth,
			height: scaledHeight
		})
		.styles({
			width: `${width}px`,
			height:  `${height}px`
		});

	let contextHover = canvasHover.node().getContext("2d");
	contextHover.scale(PR, PR);

	let canvasOverlay = container.select("#canvasOverlay")
		.attrs({
			width: scaledWidth,
			height: scaledHeight
		})
		.styles({
			width: `${width}px`,
			height:  `${height}px`
		});

	let contextOverlay = canvasOverlay.node().getContext("2d");
	contextOverlay.scale(PR, PR);

	let colorToNode = {};
	let nextCol = 1;
	function genColor(){
		let ret = [];
		if (nextCol < 16777215){
			ret.push(nextCol & 0xff); //R
			ret.push((nextCol & 0xff00) >> 8); //G
			ret.push((nextCol & 0xff0000) >> 16); //B

			nextCol += 1;
		}
		let col = "rgb(" + ret.join(',') + ")";
		return col;
	}

	d3.csv("data.csv", (error, data) => {

		let xVar = "date",
			yVar = "G",
			xFormat = d3.timeFormat("%Y");

		data.forEach(d => {
			d.pointID = genColor();
			d.mins = +d.mins;
			d.played = +d.played;
			d.age = +d.age;
			d.G = +d.G;
			d.NPG = +d.NPG;
			d.date = d3.timeParse("%Y-%m-%d")(d.date);
		});
		
		let x = d3.scaleTime()
	    .domain([new Date("1955-01-01"), new Date()])
	    .range([margin.left, width - margin.right]);

    let y = d3.scaleLinear()
	    .domain([0, d3.max(data, d => +d.G)])
	    .range([height-margin.bottom, margin.top]);

		let voronoi = d3.voronoi()
		    .x(d => x(d[xVar]))
		    .y(d => y(d[yVar]))
		    .extent([[-margin.left, -margin.top], [width + margin.right, height + margin.bottom]]);

    let colours = d3.scaleOrdinal()
    	.domain(["Cristiano Ronaldo", "Lionel Messi", "Raúl", "Eusébio", "Alfredo Di Stéfano", "Gerd Müller"])
    	.range(["#00218D", "#0083EB", "#FF2B4F", "#FCAB27", "#00F1B1", "#FF49EF"]);

	  svg.append("g")
	  	.attrs({
	  		class: "axis x",
	  		transform: `translate(0,${height - margin.bottom})`
	  	})
	    .call(d3.axisBottom(x).ticks(6).tickFormat(xFormat));

	  svg.append("g")
	  	.attrs({
	  		class: "axis y",
	  		transform: `translate(${margin.left}, 0)`
	  	})
	    .call(d3.axisLeft(y).ticks(null, ".0f"));

	    titler("y", "Goals");

    let linesData = d3.nest()
    	.key(d => d.id)
    	.entries(data);

  	linesData.forEach((d,i) => {
  		d.lastVal = d.values.slice(-1)[0];
  		d.firstVal = d.values.slice(1)[0];  		
  		let initialVal = Object.assign({}, d.firstVal);
  		initialVal.mins = 0;
  		initialVal.played = 0;
  		initialVal.G = 0;
  		initialVal.NPG = 0;
  		d.values.unshift(initialVal);
  		d.colour = colours.domain().includes(d.lastVal.name) ? colours(d.lastVal.name):"#ccc";
  		d.strokeWidth = colours.domain().includes(d.lastVal.name) ? 3:1;
  		return d
  	});

		let pathVoronoi = d3.line()
			.context(contextHover);

  	voronoi.polygons(data).forEach((d,i) => {
  		contextHover.fillStyle = data[i].pointID;
  		contextHover.strokeStyle = data[i].pointID;
			contextHover.lineWidth = 0;
			contextHover.beginPath();
			pathVoronoi(d);
			contextHover.fill();
			contextHover.stroke();
  	});

  	linesData.sort((a,b) => a.lastVal.G - b.lastVal.G);

		let path = d3.line()
			.x(d => x(d[xVar]))
			.y(d => y(d[yVar]))
			.context(context);





// 		function action(){
// 	// Function that will animate between two paths for any array of [from, to] path strings
// 	function pathTween(pairs, precision, ticks, duration) {

// 		let pointHolder = [];

// 		pairs.forEach(p => {
// 			let from = p[0];
// 			let to = p[1];
// 		  let path0 = spp.svgPathProperties(from);
// 		  let path1 = spp.svgPathPro.csvperties(to);
// 		  let n0 = path0.getTotalLength();
// 		  let n1 = path1.getTotalLength();

// 		  // Uniform sampling of distance based on specified precision.
// 		  let distances = [0], i = 0, dt = precision / Math.max(n0, n1);
// 		  while ((i += dt) < 1) distances.push(i);
// 		  distances.push(1);
		  
// 		  // Compute point-interpolators at each distance.
// 		  let points = distances.map(function(f) {
// 		    let p0 = path0.getPointAtLength(f * n0),
// 		        p1 = path1.getPointAtLength(f * n1);
// 		    return d3.interpolate([p0.x, p0.y], [p1.x, p1.y]);
// 		  });

// 		  pointHolder.push({points: points, colour:p[2], lineWidth:p[3]});

// 		});
		  
// 		  let animate = d3.interval(function(t){
// 		    if(t >= duration){
// 		      context.clearRect(0, 0, width, height);
// 			    pointHolder.forEach(ph => {
// 			    	let c;
// 			    	context.strokeStyle = ph.colour;
// 			    	context.fillStyle = ph.colour;
// 			    	context.lineWidth = ph.lineWidth;
// 			    	context.beginPath();
// 				    ph.points.map(p => p(1)).forEach(function(p, i) {
// 				      context[i == 0 ? "moveTo" : "lineTo"](...p);
// 				      if(i == ph.points.length-1) c = p;
// 				    });
// 				    context.stroke();
// 				    context.beginPath();
// 			      context.arc(...c, 4, 0, Math.PI * 2);
// 			      context.globalAlpha = 0.6;
// 			      context.fill();
// 			      context.globalAlpha = 1;
// 			      context.lineWidth = 1;
// 			      context.stroke();
// 			    });
// 		      animate.stop();
// 		    }else{		  
// 			    context.clearRect(0, 0, width, height);
// 			    pointHolder.forEach(ph => {
// 			    	let c;
// 			    	context.strokeStyle = ph.colour;
// 			    	context.fillStyle = ph.colour;
// 			    	context.lineWidth = ph.lineWidth;
// 			    	context.beginPath();
// 				    ph.points.map(p => p(t/duration)).forEach(function(p, i) {
// 				      context[i == 0 ? "moveTo" : "lineTo"](...p);
// 				      if(i == ph.points.length-1) c = p;
// 				    });
// 				    context.stroke();
// 				    context.beginPath();
// 			      context.arc(...c, 4, 0, Math.PI * 2);
// 			      context.globalAlpha = 0.6;
// 			      context.fill();
// 			      context.globalAlpha = 1;
// 			      context.lineWidth = 1;
// 			      context.stroke();
// 			    });
		    	
// 		    }
		    
// 		  },(duration/ticks));
// 	}

// 	// Path string generator for old paths
// 	let lineGen1 = d3.line()
// 			.x(d => x(+d.mins))
// 			.y(d => y(+d.G));

// 	// Path string generator for new paths
// 	let lineGen2 = d3.line()
// 			.x(d => x(+d.mins))
// 			.y(d => y(+d.NPG));

// 	// Create and populate an array of old and new paths
// 	let pathPairs = [];
// 	linesData.forEach(l => {
// 		pathPairs.push([lineGen1(l.values), lineGen2(l.values), l.colour, l.strokeWidth])
// 	});

// 	// Update voronoi polygon generator
// 	voronoi
// 	.x(d => x(+d.mins))
// 	.y(d => y(+d.NPG))
// 	.extent([[-margin.left, -margin.top], [width + margin.right, height + margin.bottom]]);

// 	// Re-draw voronoi
// 	contextHover.clearRect(0, 0, scaledWidth, scaledHeight);
// 	voronoi.polygons(data).forEach((d,i) => {
// 		contextHover.fillStyle = data[i].pointID;
// 		contextHover.lineWidth = 0.5;
// 		contextHover.beginPath();
// 		pathVoronoi(d);
// 		contextHover.fill();
// 	});

// 	// Update path generator
// 	path
// 		.x(d => x(+d.mins))
// 		.y(d => y(+d.NPG))
// 		.context(context);

// 	// Update overlay path generator
// 	pathOverlay
// 		.x(d => x(+d.mins))
// 		.y(d => y(+d.NPG));

// 	// Reposition permaLabels

// 	permaLabels
// 		.transition()
// 		.ease(d3.easeLinear)
// 		.duration(1000)
// 		.attr("transform", d => `translate(${x(+d.lastVal.mins)}, ${y(+d.lastVal.NPG)})`);
		  	
// 	svg.select(".axis.y .title")
// 		.html("Non-penalty")
// 		.clone()
// 		.attrs({
// 			y: 16
// 		})
// 		.html("goals");

// 	// Update mouse events
// 	canvas.on("mousemove", () => {
				
// 		contextOverlay.clearRect(0, 0, scaledWidth, scaledHeight);

// 		let coords = d3.mouse(canvas.node());
// 		let pixCol = contextHover.getImageData(coords[0]*PR, coords[1]*PR, 1, 1).data;
// 		pixCol = `rgb(${pixCol[0]},${pixCol[1]},${pixCol[2]})`;
// 		let dataPoint = data.filter(d => d.pointID == pixCol)[0];
// 		let dataID = dataPoint.id;
// 		let dataGroup = linesData.filter(d => d.key == dataID)[0];

// 		tooltip
// 			.styles({
// 				left: `${x(dataPoint.mins)}px`,
// 				top: `${y(dataPoint.NPG)}px`,
// 				display: "block"
// 			})
// 			.select(".inner")
// 			.html(dataPoint.name);

// 		[dataGroup].forEach((d,i) => {
// 			contextOverlay.strokeStyle = "white";
// 			contextOverlay.lineWidth = d.strokeWidth + 6;
// 			contextOverlay.beginPath();
// 			pathOverlay(d.values);
// 			contextOverlay.stroke();
// 			contextOverlay.strokeStyle = colours.domain().includes(dataPoint.name) ? colours(dataPoint.name):"#212121";
// 			contextOverlay.lineWidth = 5;
// 			contextOverlay.beginPath();
// 			pathOverlay(d.values);
// 			contextOverlay.stroke();
// 		});

// 	[dataGroup].forEach((d,i) => {
// 			contextOverlay.lineWidth = 1;
// 			contextOverlay.fillStyle = colours.domain().includes(dataPoint.name) ? colours(dataPoint.name):"#212121";
// 			contextOverlay.beginPath();
// 	    contextOverlay.arc(x(+d.lastVal.mins), y(+d.lastVal.NPG), 5, 0, Math.PI * 2);
// 	    contextOverlay.fill();
// 		});

// 	svg.selectAll(".permaLabel")
// 			.attrs({
// 				display: d => d.lastVal.name == dataPoint.name ? "none":"block"
// 			});

// 	});

// 	canvas.on("mouseout", () => {
// 		contextOverlay.clearRect(0, 0, scaledWidth, scaledHeight);
// 		tooltip
// 			.styles({
// 				display: "none"
// 			})
// 			.select(".inner")
// 			.html("");
// 	});

// 	pathTween(pathPairs, 4, 50, 1000);
// }

	// Transition
	// d3.select("h1").on("click", () => {
	// 	action();
	// });





		let pathOverlay = d3.line()
			.x(d => x(d[xVar]))
			.y(d => y(d[yVar]))
			.context(contextOverlay);

		let goalLines = linesData.forEach((d,i) => {
			if(colours.domain().includes(d.lastVal.name)){
				context.strokeStyle = "white";
				context.lineWidth = d.strokeWidth * 2;
				context.beginPath();
				path(d.values);
				context.stroke();				
			}
			context.strokeStyle = d.colour;
			context.lineWidth = d.strokeWidth;
			context.beginPath();
			path(d.values);
			context.stroke();
		});

		let circles = linesData.forEach((d,i) => {
			context.lineWidth = 1;
			context.strokeStyle = d.colour;
			context.fillStyle = d.colour;
			context.beginPath();
      context.arc(x(+d.lastVal[xVar]), y(+d.lastVal[yVar]), 4, 0, Math.PI * 2);
      context.globalAlpha = 0.6;
      context.fill();
      context.globalAlpha = 1;
      context.stroke();
		});

		let permaLabels = svg.selectAll("text.permaLabel")
			.data(linesData.filter(d => colours.domain().includes(d.lastVal.name)))
			.enter()
			.append("text")
			.attrs({
				transform: d => `translate(${x(+d.lastVal[xVar])}, ${y(+d.lastVal[yVar])})`,
				class: d => `permaLabel ${d.lastVal.name.replace(/ /g,"")}`,
				"text-anchor": "middle",
				y: -8
			})
			.styles({
				fill: "none",
				stroke: "white",
				"stroke-width": 3
			})
			.html(d => d.lastVal.name.split(" ").slice(-1)[0].replace(/Stéfano/g,"Di Stéfano"))
			.clone()
			.styles({
				fill: d => d.colour,
				stroke: "none"
			})
			.html(d => d.lastVal.name.split(" ").slice(-1)[0].replace(/Stéfano/g,"Di Stéfano"));

		// let permaLabels = linesData.filter(d => colours.domain().includes(d.lastVal.name)).forEach((d,i) => {
		// 	context.fillStyle = d.colour;
		// 	context.fillText(d.lastVal.name.split(" ").slice(-1), x(+d.lastVal.mins), y(+d.lastVal.G)-8);
		// });

		canvas.on("mousemove", () => {
			
			contextOverlay.clearRect(0, 0, scaledWidth, scaledHeight);

			let coords = d3.mouse(canvas.node());

			let pixCol = contextHover.getImageData(coords[0]*PR, coords[1]*PR, 1, 1).data;
			pixCol = `rgb(${pixCol[0]},${pixCol[1]},${pixCol[2]})`;
			let dataPoint = data.filter(d => d.pointID == pixCol)[0];
			let dataID = dataPoint.id;
			let dataGroup = linesData.filter(d => d.key == dataID)[0];

			tooltip
				.styles({
					left: `${x(dataPoint[xVar])}px`,
					top: `${y(dataPoint[yVar])+20}px`,
					display: "block"
				})
				.select(".inner")
				.html(dataPoint.name);

			[dataGroup].forEach((d,i) => {
				contextOverlay.strokeStyle = "white";
				contextOverlay.lineWidth = d.strokeWidth + 6;
				contextOverlay.beginPath();
				pathOverlay(d.values);
				contextOverlay.stroke();
				// contextOverlay.strokeStyle = colours.domain().includes(dataPoint.name) ? colours(dataPoint.name):"#212121";
				contextOverlay.strokeStyle = "#212121";
				contextOverlay.lineWidth = 5;
				contextOverlay.beginPath();
				pathOverlay(d.values);
				contextOverlay.stroke();
			});

		[dataGroup].forEach((d,i) => {
				contextOverlay.lineWidth = 1;
				// contextOverlay.fillStyle = colours.domain().includes(dataPoint.name) ? colours(dataPoint.name):"#212121";
				contextOverlay.fillStyle = "#212121";
				contextOverlay.beginPath();
	      contextOverlay.arc(x(+d.lastVal[xVar]), y(+d.lastVal[yVar]), 5, 0, Math.PI * 2);
	      contextOverlay.fill();
			});

		svg.selectAll(".permaLabel")
				.attrs({
					display: d => d.lastVal.name == dataPoint.name ? "none":"block"
				});

		});

		canvas.on("mouseout", () => {
			contextOverlay.clearRect(0, 0, scaledWidth, scaledHeight);
			tooltip
				.styles({
					display: "none"
				})
				.select(".inner")
				.html("");
		});

		d3.select(".axisToggle.y select").on("change", () => {

			let x1 = x, y1 = y, xFormat1 = xFormat, newY;

			if(d3.select(".axisToggle.y select").node().value == "exclude"){
				newY = "NPG";
				reDraw([xVar, yVar, xVar, newY], [x, y, x1, y1], xFormat1, [context, contextHover, contextOverlay], canvas, [width, height], [pathVoronoi, path, pathOverlay], [data, linesData, voronoi], colours, tooltip);
				titler("y", "Goals (excl. penalties)");
				yVar = "NPG";
			}else{
				newY = "G";
				reDraw([xVar, yVar, xVar, newY], [x, y, x1, y1], xFormat1, [context, contextHover, contextOverlay], canvas, [width, height], [pathVoronoi, path, pathOverlay], [data, linesData, voronoi], colours, tooltip);
				titler("y", "Goals");
				yVar = "G";
			}

		});

		d3.select(".axisToggle.x select").on("change", () => {

			let newX, x1, xFormat1, y1=y;

			if(d3.select(".axisToggle.x select").node().value == "minutes"){
				newX = "mins";
				x1 = d3.scaleLinear().domain([0,13000]).range([margin.left, width-margin.right]);
				xFormat1 = d3.format(",.0f");
				reDraw([xVar, yVar, newX, yVar], [x, y, x1, y1], xFormat1, [context, contextHover, contextOverlay], canvas, [width, height], [pathVoronoi, path, pathOverlay], [data, linesData, voronoi], colours, tooltip);
				titler("x", "Minutes");
				xVar = "mins";
				x = x1;
			}else if(d3.select(".axisToggle.x select").node().value == "age"){
				newX = "age";
				x1 = d3.scaleLinear().domain([17,41]).range([margin.left, width-margin.right]);
				xFormat1 = d3.format(",.0f");
				reDraw([xVar, yVar, newX, yVar], [x, y, x1, y1], xFormat1, [context, contextHover, contextOverlay], canvas, [width, height], [pathVoronoi, path, pathOverlay], [data, linesData, voronoi], colours, tooltip);
				titler("x", "Age");
				xVar = "age";
				x = x1;
			}else{
				newX = "date";
				x1 = d3.scaleTime().domain([new Date("1955-01-01"), new Date()]).range([margin.left, width - margin.right]);
				xFormat1 = d3.timeFormat("%Y");
				reDraw([xVar, yVar, newX, yVar], [x, y, x1, y1], xFormat1, [context, contextHover, contextOverlay], canvas, [width, height], [pathVoronoi, path, pathOverlay], [data, linesData, voronoi], colours, tooltip);
				titler("x", "");
				xVar = "date";
				x = x1;
			}

		});

	});
</script>

</body>
</html>